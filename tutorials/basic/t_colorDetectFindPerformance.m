function [validationData,extraData] = t_colorDetectFindPerformance(varargin)
% [validationData,extraData] = t_colorDetectFindPerformance(varargin)
%
% Classify data generated by
%   t_coneCurrentEyeMovementsResponseInstances.
% That tutorial generates multiple noisy instances of responses for color
% Gabors and saves them out.  Here we read the output and use an
% SVM to build a computational observer that gives us percent correct, and
% then do this for multiple contrasts.  The output of this tutorial can
% then be used by
%   t_colorGaborDetectThresholdsOnLMPlane
% to find and plot thresholds.
%
% See also
%   t_coneCurrentEyeMovementsResponseInstances,
%   t_colorGaborDetectIllustrateClassificationBoundary,
%   t_plotGabotDetectThresholdsOnLMPlane.
%
% Key/value pairs
%  'rParams' - Value the is the rParams structure to use.  Default empty,
%     which then uses defaults produced by generation function.
%   'testDirectionParams' - Value is the testDirectionParams structure to use
%   'freezeNoise' - true/false (default false).  Freezes all noise so that results are reproducible.
%     If there is no noise set, this leaves it alone.
%   'compute' - true/false (default true).  Do the computations.
%   'generatePlots' - true/false (default true).  Produce any plots at
%      all? Other plot options only have an effect if this is true.
%   'plotPsychometric' - true/false (default false).  Produce
%       psychometric function output graphs.
%   'plotSvmBoundary' - true/false (default false).  Plot classification boundary
%   'plotPCAAxis1' - First PCA component to plot (default 1)
%   'plotPCAAxis2' - Second PCA component to plot (default 2)
%   'delete' - true/false (default true).  Delete the response instance
%        files.  Useful for cleaning up utput when we are done with
%        it.  If this is true, output files are deleted at the end.
%        Does not currently delete figures or parent directories, but maybe
%        it should.

%% Parse input
p = inputParser;
p.addParameter('rParams',[],@isemptyorstruct);
p.addParameter('testDirectionParams',[],@isemptyorstruct);
p.addParameter('thresholdParams',[],@isemptyorstruct);
p.addParameter('freezeNoise',false,@islogical);
p.addParameter('compute',true,@islogical);
p.addParameter('generatePlots',true,@islogical);
p.addParameter('plotPsychometric',false,@islogical);
p.addParameter('plotSvmBoundary',false,@islogical);
p.addParameter('plotPCAAxis1',1,@isnumeric)
p.addParameter('plotPCAAxis2',2,@isnumeric)
p.addParameter('delete',false',@islogical);
p.parse(varargin{:});
rParams = p.Results.rParams;
testDirectionParams = p.Results.testDirectionParams;
thresholdParams = p.Results.thresholdParams;

%% Clear
if (nargin == 0)
    ieInit; close all;
end

%% Get the parameters we need
%
% t_colorGaborResponseGenerationParams returns a hierarchical struct of
% parameters used by a number of tutorials and functions in this project.
if (isempty(rParams))
    rParams = responseParamsGenerate;
    
    % Override some defult parameters
    %
    % Set duration equal to sampling interval to do just one frame.
    rParams.temporalParams.stimulusDurationInSeconds = 200/1000;
    rParams.temporalParams.stimulusSamplingIntervalInSeconds = rParams.temporalParams.stimulusDurationInSeconds;
    rParams.temporalParams.secondsToInclude = rParams.temporalParams.stimulusDurationInSeconds;
    rParams.temporalParams.emPathType = 'none';
    
    rParams.mosaicParams.integrationTimeInSeconds = rParams.temporalParams.stimulusDurationInSeconds;
    rParams.mosaicParams.isomerizationNoise = 'random';     % Type coneMosaic.validNoiseFlags to get valid values
    rParams.mosaicParams.osNoise = 'random';                % Type outerSegment.validNoiseFlags to get valid values
    rParams.mosaicParams.osModel = 'Linear';
end

% Fix random number generator so we can validate output exactly
if (p.Results.freezeNoise)
     rng(1);
     if (strcmp(rParams.mosaicParams.isomerizationNoise, 'random'))
         rParams.mosaicParams.isomerizationNoise = 'frozen';
     end
     if (strcmp(rParams.mosaicParams.osNoise, 'random'))
         rParams.mosaicParams.osNoise = 'frozen';
     end
end

%% Parameters that define the LM instances we'll generate here
%
% Make these numbers small (trialNum = 2, deltaAngle = 180,
% nContrastsPerDirection = 2) to run through a test quickly.
if (isempty(testDirectionParams))
    testDirectionParams = instanceParamsGenerate;
end

%% Parameters related to how we find thresholds from responses
if (isempty(thresholdParams))
    thresholdParams = thresholdParamsGenerate;
end

%% Set up the rw object for this program
rwObject = IBIOColorDetectReadWriteBasic;
readProgram = 't_coneCurrentEyeMovementsResponseInstances';
writeProgram = mfilename;

constantParamsList = {rParams.topLevelDirParams, rParams.mosaicParams, rParams.oiParams, rParams.spatialParams,  rParams.temporalParams,  rParams.backgroundParams, testDirectionParams};

%% Compute if desired
if (p.Results.compute)
    
    % Read data for the no stimulus condition
    fprintf('Reading no stimulus data ... \n');
    colorModulationParamsTemp = rParams.colorModulationParams;
    colorModulationParamsTemp.coneContrasts = [0 0 0]';
    colorModulationParamsTemp.contrast = 0;
    paramsList = constantParamsList;
    paramsList{numel(paramsList)+1} = colorModulationParamsTemp;
    clear 'colorModulationParamsTemp'
    ancillaryData = rwObject.read('ancillaryData',paramsList,readProgram);
    noStimData = rwObject.read('responseInstances',paramsList,readProgram);
    % Only keep the data we will visualize
    if isfield(thresholdParams, 'trialsUsed')
        fprintf('Only using %d of the computed %d trials\n', thresholdParams.trialsUsed, size(noStimData.responseInstanceArray.theMosaicIsomerizations,1));
        noStimData.responseInstanceArray.theMosaicIsomerizations = noStimData.responseInstanceArray.theMosaicIsomerizations(1:thresholdParams.trialsUsed,:,:);
        if isempty(noStimData.responseInstanceArray.theMosaicPhotocurrents)
            noStimData.responseInstanceArray.theMosaicPhotocurrents = [];
        else
            noStimData.responseInstanceArray.theMosaicPhotocurrents = noStimData.responseInstanceArray.theMosaicPhotocurrents(1:thresholdParams.trialsUsed,:,:);
        end
    end

    % Get out some data we'll want
    nTrials = numel(noStimData.responseInstanceArray);
    testConeContrasts = ancillaryData.testConeContrasts;
    testContrasts = ancillaryData.testContrasts;
    
    % If everything is working right, rParams and ancillaryData.rParams
    % should be identical structs. Same for testDirectionParams and ancillaryParams.instanceParams
    % Check for that below.
    checkStructs('rParams', rParams, 'ancillaryParams.rParams', ancillaryData.rParams);
    checkStructs('testDirectionParams', testDirectionParams, 'ancillaryParams.instanceParams', ancillaryData.instanceParams);
    fprintf('done\n');
    
    % Do SVM for each test contrast and color direction.
    %
    % The work is done inside routine classifyForOneDirectionAndContrast.  We needed to
    % encapsulate it there to make parfor happy.
    %
    % If you don't have a computer configured to work with parfor, you may need
    % to change the parfor here to a plain for loop.
    tic
    parforConditionStructs = responseGenerationParforConditionStructsGenerate(testConeContrasts,testContrasts);
    for kk = 1:length(parforConditionStructs)
        thisConditionStruct = parforConditionStructs{kk};
        colorModulationParamsTemp = rParams.colorModulationParams;
        colorModulationParamsTemp.coneContrasts = thisConditionStruct.testConeContrasts;
        colorModulationParamsTemp.contrast = thisConditionStruct.contrast;
        paramsList = constantParamsList;
        paramsList{numel(paramsList)+1} = colorModulationParamsTemp;
        thisConditionStruct.paramsList = paramsList;
        parforConditionStructs{kk} = thisConditionStruct;
    end
    
    nParforConditions = length(parforConditionStructs);
    parforRanSeeds = randi(1000000,nParforConditions,1)+1;
    usePercentCorrect = zeros(size(testConeContrasts,2),1);
    useStdErr = zeros(size(testConeContrasts,2),1);
    rState = rng;
    
    parfor kk = 1:nParforConditions
        rng(parforRanSeeds(kk));
        thisConditionStruct = parforConditionStructs{kk};
        paramsList = thisConditionStruct.paramsList;
        fprintf('Reading stimulus data for condition %d of %d... \n', kk,nParforConditions);
        stimData = rwObject.read('responseInstances',paramsList,readProgram);
        if isfield(thresholdParams, 'trialsUsed')
            stimData.responseInstanceArray.theMosaicIsomerizations = stimData.responseInstanceArray.theMosaicIsomerizations(1:thresholdParams.trialsUsed,:,:);
            if isempty(stimData.responseInstanceArray.theMosaicPhotocurrents)
                stimData.responseInstanceArray.theMosaicPhotocurrents = [];
            else
                stimData.responseInstanceArray.theMosaicPhotocurrents = stimData.responseInstanceArray.theMosaicPhotocurrents(1:thresholdParams.trialsUsed,:,:);
            end
        end
        if (numel(stimData.responseInstanceArray) ~= nTrials)
            error('Inconsistent number of trials');
        end
        
        % Get performance for this condition.  Optional parameters control
        % whether or not the routine returns a handle to a plot that
        % illustrates the classifier.
        [usePercentCorrect(kk),useStdErr(kk),h] = ...
            classifyForOneDirectionAndContrast(noStimData,stimData,thresholdParams, ...
            'plotSvmBoundary',p.Results.generatePlots && p.Results.plotSvmBoundary,'plotPCAAxis1',p.Results.plotPCAAxis1,'plotPCAAxis2',p.Results.plotPCAAxis2);
        
        % Save classifier plot if we made one and then close the figure.
        if (p.Results.generatePlots && p.Results.plotSvmBoundary)
            paramsList{numel(paramsList)+1} = thresholdParams;
            rwObject.write(sprintf('svmBoundary_PCA%d_PCA%d',plotSvmPCAAxis1,plotSvmPCAAxis2), ...
                h,paramsList,writeProgram,'Type','figure');
            close(h);
        end
    end
    rng(rState);
    fprintf('Classification took %2.2f minutes\n', toc/60);
    clearvars('theData','useData','classificationData','classes');
    
    % Take the returned vector form of the performance data and put it back into the
    % matrix form we expect below and elsewhere.
    %
    % See function responseGenerationParforConditionStructsGenerate for how we
    % pack the conditions into the order that this unpacks.
    for kk = 1:nParforConditions
        thisConditionStruct = parforConditionStructs{kk};
        performanceData.percentCorrect(thisConditionStruct.ii,thisConditionStruct.jj) = usePercentCorrect(kk);
        performanceData.stdErr(thisConditionStruct.ii,thisConditionStruct.jj) = useStdErr(kk);
    end
    
    %% Tuck away other information that we want to store
    performanceData.testConeContrasts = testConeContrasts;
    performanceData.testContrasts = testContrasts;
    performanceData.rParams = rParams;
    performanceData.instanceParams = testDirectionParams;
    performanceData.thresholdParams = thresholdParams;
    clearvars('usePercentCorrect','useStdErr');
    
    %% Save classification performance data and a copy of this script
    fprintf('Writing performance data ... ');
    paramsList = constantParamsList;
    paramsList{numel(paramsList)+1} = thresholdParams;
    rwObject.write('performanceData',performanceData,paramsList,writeProgram);
    fprintf('done\n');
    
    %% Validation data
    if (nargout > 0)
        validationData.testConeContrasts = performanceData.testConeContrasts;
        validationData.testContrasts = performanceData.testContrasts;
        validationData.percentCorrect = performanceData.percentCorrect;
        validationData.stdErr = performanceData.stdErr;   
    end
    if (nargout > 1)
        extraData.rParams = performanceData.rParams;
        extraData.instanceParams = performanceData.instanceParams;
        extraData.thresholdParams = performanceData.thresholdParams;
    end
end

%% Plot performances obtained in each color direction as raw psychometric functions
if (p.Results.generatePlots && p.Results.plotPsychometric) 
    fprintf('Reading performance data ... ');
    paramsList = constantParamsList;
    paramsList{numel(paramsList)+1} = thresholdParams;
    performanceData = rwObject.read('performanceData',paramsList,writeProgram);
    fprintf('done\n');
    
    for ii = 1:size(testConeContrasts,2)
        hFig = figure; clf;
        errorbar(testContrasts, squeeze(performanceData.percentCorrect(ii,:)), squeeze(performanceData.stdErr(ii, :)), ...
            'ro-', 'LineWidth', rParams.plotParams.lineWidth, 'MarkerSize', rParams.plotParams.markerSize, 'MarkerFaceColor', [1.0 0.5 0.50]);
        axis 'square'
        set(gca, 'YLim', [0 1.0],'XLim', [testContrasts(1) testContrasts(end)], 'FontSize', rParams.plotParams.axisFontSize);
        xlabel('contrast', 'FontSize' ,rParams.plotParams.labelFontSize, 'FontWeight', 'bold');
        ylabel('percent correct', 'FontSize' ,rParams.plotParams.labelFontSize, 'FontWeight', 'bold');
        box off; grid on
        title(sprintf('LMS = [%2.2f %2.2f %2.2f]', testConeContrasts(1,ii), testConeContrasts(2,ii), testConeContrasts(3,ii)), ...
            'FontSize',rParams.plotParams.titleFontSize);
        rwObject.write(sprintf('performanceData_%d',ii),hFig,paramsList,writeProgram,'Type','figure');
    end
end

%% Delete output data if desired
%
% Doesn't delete figures.  
if (p.Results.delete)
    paramsList = constantParamsList;
    paramsList{numel(paramsList)+1} = thresholdParams;
    rwObject.delete('performanceData',paramsList,writeProgram);
end
end

% Function to check for struct equality
function checkStructs(struct1Name, struct1, struct2Name, struct2)
    compareStringFields = true;
    graphMismatchedData = false;
    customTolerances = [];
    tolerance = 1e-12;
    structCheck = RecursivelyCompareStructs(...
        struct1Name, struct1, ...
        struct2Name, struct2, ...
        tolerance, customTolerances, graphMismatchedData, compareStringFields, []);
    if (~isempty(structCheck))
        % Oh oh, structs do not match. Print mismatched fields
        for k = 1:numel(structCheck)
            fprintf(2,'\t[%d]. %s\n', k, structCheck{k});
        end
        error('\n<strong>%s and %s are NOT identical structs. </strong>\n', struct1Name, struct2Name);
    else
        fprintf('%s and %s are identical structs\n', struct1Name, struct2Name);
    end
end

